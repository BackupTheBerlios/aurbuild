#!/usr/bin/python
#
#   aurbuild
#
#   Copyright (C) 2005-2007 by Tyler Gates <TGates81@gmail.com>
#   Copyright (C) 2008 by Loui Chang <louipc.ist@gmail.com>
#  
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License version 2 
#   as published by the Free Software Foundation.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#  
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

import os, sys, tarfile, urllib, signal, getopt, time, glob 
import aurbuild.pacman
import aurbuild.version
import aurbuild.find
import aurbuild.aurparse
import aurbuild.execute
import aurbuild.utils
from shutil import rmtree, copytree, copy
from subprocess import Popen

# globals
PROGRAM_VERSION = '1.8.3'
PROGRAM_NAME = os.path.basename(sys.argv[0])
AUTHORS = 'Tyler Gates, Loui Chang'

apacman			= aurbuild.pacman
aversion		= aurbuild.version
afind			= aurbuild.find
aaurparse 		= aurbuild.aurparse
aexec			= aurbuild.execute
autils			= aurbuild.utils
aurbuild_home		= '/var/tmp/aurbuild'
makepkg_config		= '/etc/makepkg.conf'
uid			= os.getuid()
gid			= os.getgid()
build_dir	 	= os.path.join(aurbuild_home, 'build')
save_dir 		= os.path.join(aurbuild_home, 'pkgbuilds')
editor			= os.getenv('EDITOR')
cookiefile 		= os.getenv('HOME') + '/.aurbuild/aurcookie.lwp'
PKGEXT			= 'pkg.tar.gz'
# these will be populated later
builduser_uid		= None
builduser_gid		= None
working_pkg		= None
# this will be build_dir/working_pkg
pkg_build_dir		= 'dummy'
aur_tarfile		= 'dummy'

if editor == None:
	editor = ['']
else:
	# get editor with list separated args
	editor = editor.split(' ')
abs_root 	= '/var/abs'
pm_db_root 	= '/var/lib/pacman'
pm_cache	= '/var/cache/pacman'
installed_dir 	= pm_db_root + '/local'
aursite 	= 'http://aur.archlinux.org/'
# for filter_deps
filtered	= []
db_pkgs		= []
db_paths	= []
		
def cleanup():
	if os.path.isdir(pkg_build_dir):
		rmtree(pkg_build_dir)
	if aur_tarfile != None:
		if os.path.isfile(aur_tarfile):
			os.remove(aur_tarfile)

def handler(signo, frame):
	if signo == 2:
		cleanup()
		sys.exit(130)
	elif signo == 15:
		cleanup()
		sys.exit(143)

def usage():
	print 'usage: %s [options] [package] <package>'%PROGRAM_NAME
	print ''
	print 'options:'
	print '  -h, --help            show this help message and exit'
	print '  -v, --version         display version and exit'
	print '  --verbose             verbose search output'
	print '  -b, --builddeps       build and install missing ' + \
					'dependencies from abs'
	print '  -s, --syncdeps        install missing dependencies with pacman'
	print '  -o \"OPTS\", --builder-opts=\"OPTS\"'
	print '                        pass OPTS to makepkg during build'
	print '  -e, --save            save build files in `'+save_dir+'\''
	print '  -l, --local           use build files found in `'+save_dir+'\''
	print '                        instead of AUR'
	print '  -f, --official        build official packages found in `' + \
					abs_root+'\''
	print '                        instead of AUR'
	print '  --auto-build          bypass menu and build ' + \
					'automatically (DANGEROUS)'
	print '  -u, --upgrade         upgrade all packages installed ' + \
					'from unsupported AUR'
	print '  -n, --noconfirm       bypass any confirmation messages ' + \
					'by answering yes'
	print '  -x, --noinstall       do not install package after building'
	print '  -m, --rm-make-deps    remove uneeded make dependencies'
	print '  -c  --clean           clean the build directory'
	print '  -S, --search          search aur for single [keyword]'
#	print '  -V, --vote            vote for a package'
#	print '  -U, --unvote          unvote for a package'

# examine makepkg.conf and set more globals
if os.access(makepkg_config, os.F_OK|os.R_OK):
	try:
		BUILDENV = autils.echo_bash_vars(makepkg_config,
			'${BUILDENV[@]}', array=True)
	except Exception, e:
		print >>sys.stderr.write(str(e))
		sys.exit(1)

	valid_buildenv = []
	for var in BUILDENV:
		if var[0] != '!':
			valid_buildenv.append(var)

	if 'color' in valid_buildenv: USE_COLOR = 'y'
	else: USE_COLOR = 'n'

	if 'fakeroot' in valid_buildenv: USE_FAKEROOT = 'y'
	else: USE_FAKEROOT = 'n'

	
	out = autils.echo_bash_vars(makepkg_config, '$PKGDEST:$SRCDEST:$CARCH')
	out = out.split(':')
	
	PKGDEST = out[0]
	SRCDEST = out[1]
	CARCH = out[2]
	del(out)
else:
	print >>sys.stderr.write('Error: ' + makepkg_config +
			' is missing or read permissions are denied.')
	sys.exit(1)

signal.signal(signal.SIGINT, handler)
signal.signal(signal.SIGTERM, handler)

try:
	opts, args = getopt.getopt(sys.argv[1:], 'hvbso:elfunxmcS',
		['help', 'version', 'verbose', 'builddeps', 'syncdeps',
		'builder-opts=', 
		'save', 'local', 'official', 'auto-build', 'upgrade',
		'noconfirm', 'noinstall', 'rm-make-deps', 'clean',
		'search', 'url='])
except getopt.GetoptError, e:
	usage()
	print 'Error: ' + str(e)
	sys.exit(1)

VERSION		= 0
VERBOSE		= 0
BUILDDEPS	= 0
SYNCDEPS	= 0
BUILDER_OPTS	= 0
SAVE		= 0
LOCAL		= 0
OFFICIAL	= 0
AUTO_BUILD	= 0
UPGRADE		= 0
NOCONFIRM	= 0
NOINSTALL	= 0
CLEAN		= 0
SEARCH		= 0
VOTE		= 0
UNVOTE		= 0
RM_MDEPS	= 0
BUILDER_OPTARGS	= ''
OFFICIAL_PATH	= abs_root

for opt, optarg in opts:
	if opt in ['-h', '--help']: usage(); sys.exit(0)
	if opt in ['-v', '--version']: VERSION = 1
	if opt in ['--verbose']: VERBOSE = 1
	if opt in ['-b', '--builddeps']: BUILDDEPS = 1
	if opt in ['-s', '--syncdeps']: SYNCDEPS = 1
	if opt in ['-o', '--builder-opts']: 
		BUILDER_OPTS = 1
		BUILDER_OPTARGS = optarg
	if opt in ['-e', '--save']: SAVE = 1
	if opt in ['-l', '--local']: LOCAL = 1
	if opt in ['-f', '--official']: OFFICIAL = 1
	if opt in ['--auto-build']: AUTO_BUILD = 1
	if opt in ['-u', '--upgrade']: UPGRADE =1
	if opt in ['-n', '--noconfirm']: NOCONFIRM = 1
	if opt in ['-x', '--noinstall']: NOINSTALL = 1
	if opt in ['-m', '--rm-make-deps' ]: RM_MDEPS = 1
	if opt in ['-c', '--clean' ]: CLEAN = 1
	if opt in ['-S', '--search']: SEARCH = 1
	if opt in ['--url']:
		aursite = optarg
#	if opt in ['-V', '--vote']: VOTE = 1
#	if opt in ['-U', '--unvote']: UNVOTE = 1

if VERSION:
	print PROGRAM_NAME + ' v' + PROGRAM_VERSION
	print 'Copyright (C) 2005-2008 ' + AUTHORS
	print ''
	print 'This program may be freely redistributed under'
	print 'the terms of the GNU General Public License'
	sys.exit(0)

# check for no no's:

# must have an opt
if len(opts) == 0:
	usage()
	sys.exit(1)

# must have an arg unless --upgrade or --clean are specified
if (len(args) == 0) and (not UPGRADE and not CLEAN):
	print PROGRAM_NAME + ': no target specified'
	sys.exit(1)

# --builddeps and --syncdeps can't be used together
if BUILDDEPS and SYNCDEPS:
	print PROGRAM_NAME + ': -b, --builddeps and ' + \
			'-s, --syncdeps cannot be used together'
	sys.exit(1)

# --local, --official, --auto-build, and --upgrade must be used with a dependency install method
if LOCAL or OFFICIAL or AUTO_BUILD or UPGRADE:
	if not BUILDDEPS and not SYNCDEPS:
		print PROGRAM_NAME + ': this switch requires either ' + \
				'-b, --builddeps or -s, --syncdeps'
		sys.exit(1)

# --vote and --unvote can't be used together
if VOTE and UNVOTE:
	print PROGRAM_NAME + ': -V, --vote and ' + \
			'-U, --unvote cannot be used together'
	sys.exit(1)

def color(text, color_alias):
	if USE_COLOR == 'y':
		color_dict = {
			'grey':		'0',
			'red':		'1',
			'green':	'2',
			'yellow':	'3',
			'blue':		'4',
			'magenta':	'5',
			'cyan':		'6',
			'white':	'7',
			'black':	'8'}
		return '\033[1;3' + color_dict[color_alias] + 'm' + text + '\033[1;0m'
	else:
		return text

def msg(text):
	if USE_COLOR == 'y':
		return color('==> ', 'green') + color(text, 'white')
	else:
		return '==> ' + text

def prepare_work_dirs():
	try:
		cleanup()
	# parent directory of aurbuild_home should exist and owned by root
		if not os.path.isdir(os.path.dirname(aurbuild_home)):
			os.makedirs(os.path.dirname(aurbuild_home))

		# aurbuild_home should be aurbuild:aurbuild with 0775	
		if not os.path.isdir(aurbuild_home):
			os.mkdir(aurbuild_home)
			os.chmod(aurbuild_home, 0775)
			os.chown(aurbuild_home, builduser_uid, builduser_uid)

		# build_dir should be the same as aurbuild_home
		if not os.path.isdir(build_dir):
			os.mkdir(build_dir)
			os.chmod(build_dir, 0775)
			os.chown(build_dir, builduser_uid, builduser_uid)

		# pkg_build_dir should be created by the builduser
		autils.user_makedirs(pkg_build_dir, builduser_uid, builduser_uid)
	except Exception, e:
		print >>sys.stderr.write('\ncould not prepare for build: ' + str(e) + '\n')
		sys.exit(1)


def get_tarball(pkg):
	
	main_url = aaurparse.pkg_main_url(pkg, aursite)

	if main_url == '':
		print >>sys.stderr.write(pkg + ': not found in AUR')
		if UPGRADE: 
			return None
		else:
			sys.exit(1)

	try:
		f = urllib.urlopen(main_url)
		raw_text = f.readlines()
		f.close()
	except IOError, e:
		raise Exception(
			'Could not retrieve needed data from:'
			'\n\t' + main_url + '\n' +str(e))

	try:
		tarball_url = aaurparse.pkg_tarball_url(raw_text, aursite)
	except Exception, e:
		raise Exception('Unable to parse tarball info. If '
			'you see this message rarely, it is\n'  
			'possible user comments have skewed the parsing '
			'results on the web page.\n')

	if tarball_url == '' and UPGRADE:
		return None
	elif tarball_url == '':
		print >>sys.stderr.write(pkg + ': possible [community] package')
		if SYNCDEPS:
			cmd = 'aurbuild --syncdeps --official '+pkg
		elif BUILDDEPS:
			cmd = 'aurbuild --builddeps --official '+pkg
		choice = raw_input('\nInstall by running `'+cmd+'\'? [Y/n]  ')
		if choice == '': choice = 'y'
		if NOCONFIRM: choice == 'y'
		choice = choice.lower()
		if choice == 'y' or choice == 'yes':
			retval = Popen(cmd, shell=True).wait()
			return None
		else:
			cleanup()
			sys.exit(1)


	try:
		tar = urllib.urlretrieve(tarball_url)[0]
		return tar
	except IOError, e:
		raise Exception(
			'Could not retrieve needed data from:'
			'\n\t' + main_url + '\n' + str(e))

def extract(file):
	extract_dir = pkg_build_dir
	# split off the extension at `.'. Up to two allowed
	file_extension = file.rsplit('.', 2)[1:]
	if 'gz' in file_extension: ext = 'gz'
	elif 'tgz' in file_extension: ext = 'gz'
	elif 'bz2' in file_extension: ext = 'bz2'
	else:
		print >>sys.stderr.write('\n' + file + ': unsupported compression. Cannot extract.\n')
		if os.path.exists(file): os.remove(file)
		cleanup()
		sys.exit(1)
	
	try:
		if os.path.isdir(extract_dir): rmtree(extract_dir)
		os.mkdir(extract_dir)
		os.chmod(extract_dir, 0775)
		os.chown(extract_dir, builduser_uid, builduser_gid) 
	except Exception, e:
		print >>sys.stderr.write('could not create temporary extraction point:')
		print >>sys.stderr.write(str(e))
		cleanup()
		sys.exit(1)

	try:
		tar_f = tarfile.open(file, 'r:' + ext)
		for member in tar_f.getmembers():
			tar_f.extract(member, extract_dir)
	except tarfile.TarError, e:
		print >>sys.stderr.write('\ncould not extract tarfile: ' + str(e) + '\n')
		if os.path.exists(file): os.remove(file)
		cleanup()
		sys.exit(1)

	# aur gives us fucked tarballs with nobody:nobody ownership... this will fix it
	def mod_extracted(dir):
		for d in os.listdir(dir):
			v = os.path.join(dir, d)
			os.chown(v, builduser_uid, builduser_gid)
			if os.path.isdir(v) and not os.path.islink(v):
				mod_extracted(v)

	# the parent directory of the extracted tarball has a setgroup id bit set from AUR. This needs to be removed:
	for j in os.listdir(extract_dir):
		jf = os.path.join(extract_dir, j)
		if os.path.isdir(jf):
			os.chmod(jf, 0755)

	mod_extracted(extract_dir)

	tar_f.close()
	os.remove(file)

def get_PKGBUILD_path(parent_dir):
	results = afind.find_file(parent_dir, 'PKGBUILD')[0]
	if results != []:
		results = results[0].replace('/PKGBUILD', '')
		return results
	else:
		raise Exception('PKGBUILD not found.\n')



'''
' Give required dependency and return it if it needs to be installed or
' return group packages if it is that keyword
'	filtered = [], list
'''
def filter_deps(pkg, fd_ct, type):
	# for tabbing over tree branch symbols
	pre_space  = 2
	# spaces must be greater than pre_space
	spaces = 3
	v = fd_ct/spaces
	indents = ' '*pre_space + ('|' + ' '*spaces)*v
	sys.stdout.write(color(indents + '`- ', 'blue') + color(pkg + ': ', 'black'))
	sys.stdout.flush()
	code = apacman.operations().pacmanT(pkg)

	if code == 127:
		# see if its a group name
		group_pkgs = apacman.db_tools().get_group(pkg)
		if group_pkgs == []:
			print color('missing ' + type, 'red')
			pkg = apacman.db_tools().strip_ver_cmps(pkg)[0]

			if BUILDDEPS: 
				dep_path = autils.get_dep_path(abs_root, pkg)
				if dep_path != None:
					# a dependency is found, check it's deps and run this method again
					mdep_cans, dep_cans = autils.get_depends(dep_path + '/PKGBUILD', 'makedepends', 'depends')

					if mdep_cans or dep_cans != ['']: fd_ct += spaces

					if mdep_cans != ['']:
						for mdep_can in mdep_cans:
							filter_deps(mdep_can, fd_ct, type='[M]')

					if dep_cans != ['']: 
						for dep_can in dep_cans:
							filter_deps(dep_can, fd_ct, type='[D]')
				else:
					raise Exception(pkg + ': not found in ABS.\n')

			elif SYNCDEPS:
				# follows steps of BUILDDEPS omitting make dependencies
				if db_paths == []:
					# generate list to global
					db_paths.extend(apacman.db_tools().get_db_pkgpaths())
				if db_pkgs == []:
					# generate list to global
					for db_path in db_paths:
						descfile = db_path + '/desc'
						if os.path.isfile(descfile):
							db_pkg = apacman.db_tools().get_db_info(descfile, '%NAME%')[0]
							if db_pkg != []: db_pkgs.append(db_pkg)
				found = 0
				for db_pkg in db_pkgs:
					db_path = db_paths[db_pkgs.index(db_pkg)]
					if db_pkg != [] and pkg == db_pkg:
						found = 1
						dependsfile = db_path + '/depends'
						dep_cans = apacman.db_tools().get_db_info(dependsfile, '%DEPENDS%')
						if dep_cans != []: 
							fd_ct += spaces
							for dep_can in dep_cans:
								filter_deps(dep_can, fd_ct, type='[D]')
				if not found:
					raise Exception(pkg + ': not found in database.\n')

			# there must be no remaining deps of deps, add to list
			if not pkg in filtered: filtered.append(pkg)
		else:
			print color('group', 'cyan')
			fd_ct += 4
			for group_pkg in group_pkgs:
				filter_deps(group_pkg, fd_ct, type='[D]')
	elif code == 0:
		print color('ok ' + type, 'green')
		
	elif code != 127 and code != 0:
		raise Exception('aurbuild: fatal error while testing dependencies.\n')

	return filtered


def src_to_pm_cache(sources):
	""" copy the sources in raw format (from sources array) to pacman cache """

	cwd = os.getcwd()
	if SRCDEST == '':
		_SRCDEST = os.path.join(pm_cache, 'src')
	else:
		_SRCDEST = SRCDEST
	for source in sources:
		source_file = source.split('/')[-1]
		try:
			source_file = os.path.join(cwd, 'src', source_file)
			copy(source_file, _SRCDEST)
		except:
			pass

def get_pkgpath():
	""" get the built package path """

	cwd = os.getcwd()
	if PKGDEST == '':
		_PKGDEST = cwd
	else:
		_PKGDEST = PKGDEST

	try:
		out = autils.echo_bash_vars(os.path.join(cwd, 'PKGBUILD'),
			'${pkgname}%${pkgver}%${pkgrel}')

	except Exception, e:
		print >>sys.stderr.write('PKGBUILD syntax error: '+ str(e))
		cleanup()
		sys.exit(1)

	arch = autils.echo_bash_vars(os.path.join(cwd,'PKGBUILD'), "${arch}")

	# Make sure we can install packages built for 'any' arch
	if arch != 'any':
		arch = CARCH

	out = out.split('%')
	pkgname, pkgver, pkgrel = out[0], out[1], out[2]

	pkgpath = os.path.join(_PKGDEST, pkgname + '-' + pkgver +
			'-' + pkgrel + '-' + arch + '.' + PKGEXT)

	if os.path.exists(pkgpath):
		return pkgpath
	else:
		print >>sys.stderr.write('Error: could not find the built '
				'package in ' + pkgpath)
		print >>sys.stderr.write('In some cases this might mean the '
			'PKGDEST location does not have write and execute '
			'permissions\nfor the `aurbuild\' user or group.')
		cleanup()
		sys.exit(1)
	

def makepkgf(dep):

	cwd = os.getcwd()

	try:
		raw_sources = autils.echo_bash_vars(os.path.join(cwd, 'PKGBUILD'), '${source[@]}', array=True)
	except Exception, e:
		print >>sys.stderr.write('PKGBUILD syntax error: ' + str(e))
		cleanup()
		sys.exit(1)
	
	app = 'makepkg'
	args = ['makepkg', '-f']
	if BUILDER_OPTS and BUILDER_OPTARGS != '':
		args.extend(BUILDER_OPTARGS.split(' '))
	
	# ccache needs a writable HOME, set it here.
	env = os.environ
	env['HOME'] = aurbuild_home
	code = aexec.child_spawn(app, args, builduser_uid, builduser_gid, env)

	# copy src files over to cache
	src_to_pm_cache(raw_sources)

	if code > 0:
		print >>sys.stderr.write('\naurbuild: could not build \"' + 
			dep + '\" with makepkg.')
		print 'Build directory retained at ' + pkg_build_dir
		print 'You can visit the directory, fix the ' \
		'problem, and run makepkg.'
		sys.exit(1)
	
	return get_pkgpath()

'''
' args[0] is pkgpath
' args[1] is asdeps
'''
def install(pkgpath, asdeps=False):
	pacman_lock	= '/var/lib/pacman/db.lck'
	if os.path.isfile(pacman_lock):
		print 'Pacman is detected running.'
		print 'Once pacman exits, you may press enter to install'
		print 'Control + C to cancel.'
		raw_input()	
		
	print msg('Installing package...')

	if not asdeps:
		code = Popen(['pacman', '-U', pkgpath]).wait()
	else:
		code = Popen(['pacman', '-U', '--asdeps', pkgpath]).wait()

	if code > 0:
		raise Exception('aurbuild could not install '
				'package via pacman --upgrade.')
			
def builddeps(deplist):
        # for -b option
	cwd = os.getcwd()
        for each in deplist:
                dep_path = autils.get_dep_path(abs_root, each)
                if dep_path == None:
			raise Exception('aurbuild: dependency \"' + each + \
				'\" not found in abs.')
                        cleanup()
                        sys.exit(1)

		des_dir = os.path.join(build_dir, each)
		os.setegid(builduser_gid)
		os.seteuid(builduser_uid)

		# Remove build directory if it already exists
		if os.path.isdir(des_dir):
			rmtree(des_dir)

                copytree(dep_path, des_dir)
		os.seteuid(uid)
		os.setegid(gid)
                os.chdir(des_dir)
		pkgpath = makepkgf(each)
		if not NOINSTALL:
			try:
				install(pkgpath, asdeps=True)
			except Exception, e:
				raise

        os.chdir(cwd)
	
def menu(dir_list, package):
	files = []
	editor_cmd = editor
#	columns = int(os.getenv('COLUMNS'))
#	if columns == None: columns = 80
	columns = 80
	sep_num = 51
	seperator = '-'*sep_num
	space_num = (columns - sep_num ) / 2
	spaces = ' '*space_num
	for each in dir_list:
		if os.path.isfile(each):
			files.append(each)
	del(each)
	file_num = len(files)
	
	if not NOINSTALL:
		# open editor with .install file
		for k in files:
			extension = k.rsplit('.', 1)[1:]
			if 'install' in extension:
				editor_cmd.append(k)
				code = Popen(editor_cmd).wait()
				editor_cmd.remove(k)
				break

	def title(display, _color):
		len_disp = int(len(display))
		if len_disp > sep_num: centerspaces = ''
		else: centerspaces = ' '*((sep_num - len_disp) / 2)
		return spaces + centerspaces + color(display, _color)

	getout = False
	while not getout:
		default_choice = 'b'
		code = Popen('clear').wait()
		print '\n'
		print title(package, 'white')
		print '\n' + spaces + seperator

		i = 0
		while i < file_num:
			print spaces + '  ' + str(i+1) + ')  View/Edit ' + files[i]
			i = i + 1
		print spaces + seperator

		menu_op = "Build"
		menu_app = "makepkg"

		if not NOINSTALL:
			menu_op += " and install"
			menu_app += " and pacman"

		# Build (and install) with makepkg (and pacman)
		print spaces + color('*', 'blue') + ' b)  %s with %s.'% (menu_op, menu_app)
		default_choice = 'b'

		print spaces + '  s)  Skip this package.'
		print spaces + '  q)  Quit without building.'
		print spaces + seperator

		display_choice = default_choice.upper()
		choice = raw_input('\n' + spaces + 'Enter a selection: ['+ display_choice + '] ')
		if choice == 'b':
			return choice
		elif choice == 'v':
			return choice
		elif choice == 'q':
			cleanup()
			sys.exit(0)
		elif choice == 's':
			return choice
		elif choice.isdigit():
			if int(choice) >= 1 and int(choice) <= file_num:
				editor_cmd.append(files[int(choice)-1])
				code = Popen(editor_cmd).wait()
				editor_cmd.remove(files[int(choice)-1])
				
			else:
				print '\n' + spaces + choice + ': Invalid entry.'
				print spaces + 'Press enter to choose again.'
				raw_input(spaces)
		elif choice == '': return default_choice
		else:
			print '\n' + spaces + choice + ': Invalid entry.'
			print spaces + 'Press enter to choose again.'
			raw_input(spaces)

def init():
	# check that we have everything we need
	prog_list = ['makepkg', 'pacman', 'fakeroot']
	for prog in prog_list:
		if not autils.appcheck(prog):
			print >>sys.stderr.write('\n' + prog + ' program not found in $PATH.\n')
			sys.exit(1)
	# must be root
	if uid != 0:
		print >>sys.stderr.write('requires root access.')
		sys.exit(1)

	# ensure we have fakeroot enabled
	if USE_FAKEROOT != 'y':
		print "error: fakeroot is disabled in /etc/makepkg.conf\n" \
			"Refusing to proceed."
		sys.exit(1)

	# set up build user
	global builduser_uid
	global builduser_gid
	builduser_uid, builduser_gid = autils.prepare_build_user()
	# leave out prepare_work_dirs(), it should be called as needed

def savefiles(pkg, old_dir):

	failed = 0
	def abort_msg(msg):
		print >>sys.stderr.write('Error saving ' + pkg +  
			' to ' + save_dir + ': ' + msg)
		print >>sys.stderr.write('Aborting save...')
		
	savecan = os.path.join(save_dir, pkg)
	if not os.path.isdir(save_dir):
		try:
			os.makedirs(save_dir)
			os.chmod(save_dir, 0775)
			os.chown(save_dir, builduser_uid, builduser_uid)
		except OSError, e:
			abort_msg(str(e))
			failed = 1
	
	if os.path.isdir(savecan) and not failed:
		if not NOCONFIRM: choice = raw_input('`' + savecan + '\': directory exists. Overwrite? [Y/n]  ').lower()
		if NOCONFIRM or choice == 'y' or choice == 'yes' or choice == '':
			try:
				rmtree(savecan)
				autils.user_copytree(old_dir, savecan, builduser_uid, builduser_gid)
			except OSError, e:
				abort_msg(str(e))
				failed = 1
	elif not os.path.isdir(savecan) and not failed:
		try:
			autils.user_copytree(old_dir, savecan, builduser_uid, builduser_gid)
		except OSError, e:
			abort_msg(str(e))

def main():
	global editor, args
	rm_packages = []

	if CLEAN:
		retcode = 0
		try:
			rmtree(build_dir)
		except:
			retcode = 1
			print "Nothing to clean"

		if len(args) == 0:
			sys.exit(retcode)
	
	if SEARCH: 
		autils.search(args, VERBOSE, aursite)
		sys.exit(0)
	
	if VOTE or UNVOTE:
		import getpass, aurbuild.login

		login = aurbuild.login
		
		username = raw_input('AUR Username: ')
		password = getpass.getpass('AUR Password: ')

		code2 = 0
		for arg in args:
			if VOTE:
				print 'casting vote for ' + arg + '... ',
				sys.stdout.flush()
				try:
					code = login.aurlogin().vote(username, password, cookiefile, arg)
					if code == 2:
						print 'vote previously cast!'
					else:
						print 'success'
				except login.LoginError, e:
					print'failed: ' + str(e)
					code2 += 1
				except:
					print 'failed'
					raise
					
			elif UNVOTE:
				print 'removing vote for ' + arg + '... ',
				sys.stdout.flush()
				try:
					code = login.aurlogin().unvote(username, password, cookiefile, arg)
					if code == 2:
						print 'no vote cast!'
					else:
						print 'success'
				except login.LoginError, e:
					print 'failed: ' + str(e)
					code2 += 1
				except:
					print 'failed'
					raise
					
		# if one fails, exit with error
		if code2 > 0: sys.exit(1)
		else: sys.exit(0)

	init()
	# default to nano if no $EDITOR variable found
	if editor == ['']: 
		print "Editor environmental variable not set. Using nano... "
		time.sleep(3)
		editor = ['nano']
	editor_no_args = editor[0]
	if not autils.appcheck(editor_no_args) and not os.path.isfile(editor_no_args):
		print >>sys.stderr.write('Error: editor value \"' + editor_no_args + '\" not found on system.')
		cleanup()
		sys.exit(1)

	if UPGRADE:
		# set args to each potential AUR candidate
		args, installed = apacman.db_tools().get_foreign()

	upgrade_ct = 0
	for argo in args:
		global working_pkg, pkg_build_dir, aur_tarfile
		working_pkg = argo
		pkg_build_dir = os.path.join(build_dir, working_pkg)
		prepare_work_dirs()
		# a potential pkg work direcotory (after decompression)
		p_work_dir = os.path.join(pkg_build_dir, working_pkg)

		# retrieve tarball and prepare to build
		if LOCAL or OFFICIAL:
			if LOCAL:
				pkgbuild_root = save_dir
			if OFFICIAL:
				pkgbuild_root = OFFICIAL_PATH
			# test for its existance
			if not os.access(pkgbuild_root, os.F_OK | os.R_OK):
				print >>sys.stderr.write('Error: PKGBUILD root '+pkgbuild_root+' not found or read permissions denied.')
				cleanup()
				sys.exit(1)

			results = afind.find_dir(pkgbuild_root, argo)[0]

			if results == [] and not UPGRADE:
				print '\n\"'+argo+'\" not found under `'+pkgbuild_root+'\'\n'
				cleanup()
				sys.exit(1)
			elif results == [] and UPGRADE:
				upgrade_ct += 1
				continue
			elif results != 0:
				for r in results:
					j = os.path.join(r, 'PKGBUILD')
					if os.path.isfile(j):
						try:
							_p_name = autils.echo_bash_vars(j, '${pkgname}')
						except Exception, e:
							print >>sys.stderr.write('PKGBUID syntax error: ' + str(e))
							cleanup()
							upgrade_ct += 1
							continue

						if _p_name == argo:
							results = r
							break
				if type(results) != str: results = ''

				if results == '':
					print '\n\"'+argo+'\" not found under `'+pkgbuild_root+'\'\n'
					cleanup()
					sys.exit(1)
			
				copytree(results, p_work_dir)
				os.chown(p_work_dir, builduser_uid, builduser_uid)
				os.chmod(p_work_dir, 0775)

				try:
					work_dir = get_PKGBUILD_path(p_work_dir)
				except Exception, e:
					print >>sys.stderr.write(str(e))
					cleanup()
					sys.exit(1)
		else:
			try:
				aur_tarfile = get_tarball(argo)
			except Exception, e:
				print >>sys.stderr.write(str(e))
				cleanup()
				sys.exit(1)

			if aur_tarfile == None:
				# Probably built a community package.
				# At any rate, the loop needs to continue.
				cleanup()
				upgrade_ct += 1
				continue

			extract(aur_tarfile)

			try:
				work_dir = get_PKGBUILD_path(p_work_dir)
			except Exception, e:
				print >>sys.stderr.write(str(e))
				cleanup()
				sys.exit(1)

			
		os.chdir(work_dir)

		# Save files
		if SAVE:
			savefiles(argo, work_dir)

			# If --save is the only opt specified don't build or
			# sync. It's OK to exit here because --upgrade (which
			# follows) requires -b or -s
			if not BUILDDEPS and not SYNCDEPS:
				if argo == args[len(args)-1]:
					cleanup()
					sys.exit(0)
				else: continue

		# for --upgrade. compare versions and confirm upgrade with user
		if UPGRADE:
			pkgbuild_path = os.path.join(os.getcwd(), 'PKGBUILD')

			try:
				package = autils.echo_bash_vars(pkgbuild_path, '${pkgname}')
			except Exception, e:
				print >>sys.stderr.write('PKGBUILD syntax error (' +argo+'), unable to process:\n' + str(e))
				cleanup()
				upgrade_ct += 1
				continue

			aur = autils.echo_bash_vars(pkgbuild_path, '${pkgver}-${pkgrel}')
			
			result = aversion.vercmp().vercmp(aur, installed[upgrade_ct])

			if result == 1:
				print '\n  Target: '+package+'-'+aur+'\n'
				if not NOCONFIRM:
					choice = raw_input('\tProceed with upgrade?  [Y/n] ').lower()
					print ''
					if choice != 'y' and choice != 'yes' and choice != '':
						cleanup()
						upgrade_ct += 1
						continue
			elif result == 0:
				status = 'up to date'
				argline = argo + ' ' + installed[upgrade_ct]
				argline += ' '
				rjust_spaces = 80 - (int(len(argline)) + \
					int(len(status)))
				print argline + status.rjust(rjust_spaces, '.')
				cleanup()
				upgrade_ct += 1
				continue
			elif result == -1:
				print ':: local/%s %s seems newer than aur/%s %s'% (argo, installed[upgrade_ct], argo, aur) 
				cleanup()
				upgrade_ct += 1
				continue

		# evaulate options and go to menu if needed
		if not AUTO_BUILD:
			select = menu(os.listdir(work_dir), argo)
			if select == 's':
				cleanup()
				upgrade_ct += 1
				continue
	
		# get dependencies
		try:
			mdep_cans, dep_cans = autils.get_depends(work_dir + '/PKGBUILD', 'makedepends', 'depends')
		except Exception, e:
			print >>sys.stderr.write(str(e))
			cleanup()
			sys.exit(1)

		mdeps = []
		deps = []
		print color('==> ', 'blue') + color('Checking Buildtime Dependencies... \n', 'black')
		if mdep_cans != ['']: 
			for mdep_can in mdep_cans:
				try:
					mdeps = filter_deps(mdep_can, fd_ct=1, type='[M]')
				except Exception, e:
					print >>sys.stderr.write(str(e))
					cleanup()
					sys.exit(1)

			# reset globals for deps
			global filtered, db_pkgs, db_paths
			filtered = []
			db_pkgs = []
			db_paths = []

		print color('==> ','blue') + color('Checking Runtime Dependencies... \n', 'black')

		if dep_cans != ['']:
			for dep_can in dep_cans:
				try:
					deps = filter_deps(dep_can, fd_ct=1, type='[D]')
				except Exception, e:
					print >>sys.stderr.write(str(e))
					cleanup()
					sys.exit(1)

		# reset again for next loop of args
		filtered = []
		db_pkgs = []
		db_paths = []

		# install missing dependencies
		remove_packages = []
		zct = 0
		zdict = {1: '\nMake Dependency', 2: '\nDependency'}
		for deps_type in mdeps, deps:
			zct += 1
			if deps_type != []:
				print zdict[zct] + ' Targets: ',
				for v in deps_type: print v,
				if not NOCONFIRM:
					dep_choice = raw_input('\nProceed?  [Y/n] ').lower()
					print ''
				else: 
					print '\n'
					dep_choice = 'y'
				if dep_choice == 'y' or dep_choice == 'yes' or dep_choice == '':
					if BUILDDEPS: builddeps(deps_type)
					elif SYNCDEPS:
						try:
							apacman.syncdeps(deps_type)
						except Exception, e:
							print >>sys.stderr.write(str(e))
							cleanup()
							sys.exit(1)
					if RM_MDEPS:
						if 'make' in zdict[zct].lower():
							rm_packages.extend(deps_type)

		pkgname = makepkgf(argo)
		if not NOINSTALL:
			try:
				install(pkgname)
			except Exception, e:
				print >>sys.stderr.write(str(e))
				cleanup()
				sys.exit(1)

		upgrade_ct += 1
		cleanup()
	# check for make deps that need to be removed
	if RM_MDEPS and len(rm_packages) > 0:
		print '\nRemove Targets: ',
		for rp in rm_packages: print rp,
		if not NOCONFIRM:
			choice = raw_input('\nProceed?  [Y/n] ').lower()
			print ''
		else:
			print '\n'
			choice = 'y'
		if choice == 'y' or choice == 'yes' or choice == '':
			p_cmd = ['pacman', '-R', '--noconfirm']
			p_cmd.extend(rm_packages)
			retcode = Popen(p_cmd).wait()
	cleanup()

if __name__ == '__main__':
	try:
		main()
		sys.exit(0)
	except SystemExit, e:
		cleanup()
		sys.exit(e)
	# print pacman specific errors, users will understand these.
	except (apacman.DatabaseError, apacman.ConfigError), e:
		print >>sys.stderr.write(str(e))
		cleanup()
		sys.exit(1)
	# raise everything else not accounted for. These are problems.
	except:
		cleanup()
		raise
